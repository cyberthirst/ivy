# AGENTS.md - Ivy Development Guide

## Project Overview
Ivy is an AST interpreter for Vyper (EVM smart contract language) built for differential fuzzing.
The goal is to find semantic bugs (miscompilations) by comparing Vyper-compiled bytecode execution
against Ivy's source-level interpretation.

## Build & Test Commands

### Environment Setup
This project uses `uv` for dependency management.
```bash
uv sync --frozen --extra dev              # Install all dependencies (creates .venv/ automatically)
```

### Running Tests (use `./ivytest.sh`)
Use `./ivytest.sh` for all test runs. It provides minimal, agent-friendly output:
- On success: prints `OK: N passed in X.XXs`
- On failure: prints `FAILED` followed by just the stack trace

```bash
# Run a specific test module
./ivytest.sh tests/ivy/test_e2e.py

# Run a specific test function
./ivytest.sh tests/ivy/test_e2e.py::test_basic_call

# Run tests matching a pattern
./ivytest.sh tests/test_replay.py -k 'test_slice'

# Run with vyper export refresh (rarely needed)
./ivytest.sh --refresh tests/test_replay.py
```

### Critical Tests (MUST PASS after any change)
```bash
./ivytest.sh tests/
```
All tests must pass before committing. The time of execution of all the tests is under 2 minutes.

### Linting & Type Checking
```bash
uv run ruff check src/                    # Lint
uv run ruff format src/                   # Format
uv run ruff check src/ --fix              # Auto-fix lint issues
uv run pyright src/                       # Type check
./check.sh                                # Run all checks (ruff + pyright)
```

### Running the Fuzzer
```bash
uv run python -m src.fuzzer.generative_fuzzer
```

## Code Style Guidelines

### Imports
Use absolute imports, not relative ones.

```python
# Standard library first
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any
import copy

# Third-party
from vyper.ast import nodes as ast
from vyper.semantics.types import VyperType

# Local imports
from ivy.types import Address
from ivy.exceptions import Revert
```

### Type Annotations
- Use type hints for function signatures
- Use `Optional[T]` for nullable types
- Use `Union[A, B]` for multiple types (or `A | B` syntax)
- Type checking mode: basic (pyright)
- **Use `TYPE_CHECKING` guard** for import-only types to avoid circular imports
- **Use `from __future__ import annotations`** for forward references
```python
from __future__ import annotations
from typing import TYPE_CHECKING, Optional, Dict, Any

if TYPE_CHECKING:
    from ivy.frontend.vyper_contract import VyperContract

def foo(contract: VyperContract, b: Optional[str] = None) -> Dict[str, Any]:
    ...
```

### Testing Patterns
- **Prefer simple `test_` functions** - nothing fancy, no complex class hierarchies
- **New interpreter features MUST have e2e tests** in `tests/ivy/`
- **Avoid unit tests** for unstable/evolving behavior (e.g., specific AST mutation internals)
- Only write unit tests for stable, well-defined behavior unlikely to change
- Fixtures defined in `tests/conftest.py`
- Key fixtures: `get_contract`, `tx_failed`, `env`, `make_input_bundle`
- Inline Vyper source in tests as multi-line strings
- Tests auto-rollback state via `env.anchor()` hook
```python
def test_example(get_contract):
    src = """
@external
def foo() -> uint256:
    return 42
    """
    c = get_contract(src)
    assert c.foo() == 42

def test_revert(tx_failed):
    with tx_failed(Assert):
        c.foo()  # Should revert
```

## Key Modules

- **`src/ivy/`** - AST interpreter that executes Vyper source directly
- **`src/fuzzer/`** - Differential fuzzing: compares ivy interpretation vs compiled EVM execution
- **`src/fuzzer/runner/`** - Scenario runners: execute traces against ivy and boa (titanoboa), collect results
- **`src/fuzzer/runtime_engine/`** - Coverage-guided runtime fuzzing: generates/mutates calls to maximize code coverage
- **`src/fuzzer/mutator/`** - AST and value mutation: randomly modifies/generates Vyper source and call arguments
- **`src/unparser/`** - Converts Vyper AST back to source code
- **`tests/ivy/`** - End-to-end interpreter tests
- **`tests/vyper-exports/`** - JSON traces exported from Vyper's test suite for replay

## Key Concepts

### Titanoboa (boa)
Titanoboa is a Vyper interpreter/execution environment that compiles Vyper to EVM bytecode and runs it inside PyEVM. Ivy uses boa as the "ground truth" for differential fuzzing: if ivy and boa produce different results for the same contract, that's a potential compiler bug. Ivy interprets AST, boa the vyper-compiler-generated bytecode.

### Exports
JSON traces from Vyper's test suite. See `trace-format.json` for the schema. Load/filter with:
```python
from fuzzer.export_utils import load_all_exports, filter_exports, TestFilter
exports = load_all_exports(Path("tests/vyper-exports"))
exports = filter_exports(exports, test_filter=TestFilter().include_path("test_slice"))
```

### Contract Loading
```python
from ivy.frontend.loader import loads
c = loads(vyper_source_code)
result = c.foo()  # Call external function
```

### Environment
Singleton state management:
```python
from ivy.frontend.env import Env
env = Env().get_singleton()
env.clear_state()
with env.anchor():
    # Changes rolled back after block
```

## Worktree Workflow

> **MANDATORY**: All code changes require a worktree. Do not skip this step.

All work (fixes, new features, debugging, profiling, refactoring, cleanups...) **must** be done in a separate worktree to isolate changes and enable parallel agent workflows.

### Starting Work
Use the `wt-start.sh` script to create a worktree. The worktree is created from the **currently checked out branch**, and automatically ports any uncommitted changes from the current directory (critical when the bug is in uncommitted code):

```bash
./wt-start.sh <task-name>            # Creates worktree from current branch, applies uncommitted changes
cd <worktree-path>                # Switch to the new worktree (path printed by script)
```

The script:
1. Saves uncommitted changes (staged + unstaged) as a patch
2. Creates a new worktree from the current branch with `wt switch --create`
3. Applies the patch to the new worktree
4. Lists any untracked files that need manual copying

### When Done
After completing work, report:
1. **Worktree name** - so the user knows where to find the changes
2. **TLDR** - 1-2 sentence summary of what was done

Example:
```
Worktree: fix-slice-bounds
TLDR: Fixed off-by-one error in slice bounds checking by adjusting the upper bound comparison in eval_subscript().
```

## Guidelines for AI Agents

1. **Minimal changes**: No unnecessary abstractions. Reuse existing code.
2. **No docs**: Don't write docstrings for modules/functions unless they're complex.
3. **Comments**: Only for non-obvious logic.
4. **Focus**: Compiler correctness bugs only, not lexer/parser bugs.
5. **Testing**: Always use `./ivytest.sh` (not raw pytest). Run `./check.sh` before commits.
6. **Commits**: Add `Co-Authored-By: Claude <noreply@anthropic.com>` to commit messages.
7. **PYTHONPATH**: Already configured in `pytest.ini`. For scripts, use `uv run` which handles this automatically.
8. **Worktree**: ALWAYS create a worktree with `./wt-start.sh <task-name>` before making any code changes. No exceptions.

## Skills

Skills are task-specific guides in `skills/<name>.md`. Read the relevant skill before starting a task in that domain.

| Skill | Purpose |
|-------|---------|
| **boa** | Titanoboa testing framework - writing vyper tests, test environment |
| **vyper** | Vyper compiler internals - AST, types, compilation pipeline, debugging compiler |
| **replay** | Replaying divergences, finding root cause, debugging workflow |
| **dedup-divergences** | Batch analysis of fuzzer divergences, parallel subagent workflow |
| **testing** | Writing tests - Ivy vs BOA, property-based testing, test hygiene |
| **write-skill** | Create new skills - use this to add skills, then update this table |
| **code-review** | Dual-agent review (Claude + Codex) - bugs, architecture, cross-review, final report |
| **debugging** | Debugging bugs in Ivy/Viper/Titanoboa - structured bug reports, tracking in BUGS/ directory |